using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using Photon;

[RequireComponent(typeof(PhotonView))]
public class NetworkedBubble : Photon.MonoBehaviour {
    Bubble _bubble;
    GameObject _spiralEffectObj;

    float _syncTime = 1.5f;
    float _syncTimer = 0f;

    // Use this for initialization
    void Start () {
	}

    void OnPhotonInstantiate(PhotonMessageInfo info) {
        _bubble = GetComponent<Bubble>();
        PhotonView photonView = GetComponent<PhotonView>();
        NetworkedPlayerSpawner playerSpawner = GameObject.FindGameObjectWithTag("LevelManager").GetComponent<NetworkedPlayerSpawner>();

        // How this bubble was spawned
        // -2 = New Line, -1 = Initial board spawn, 0-3 = player, else = water bubble (for now?)
        int spawnType = (int)photonView.instantiationData[0];

        // If this was a new line bubble
        if(spawnType == -2) {
            // It should hide itself until it needs to be used

            // initialize the bubble
            _bubble.Initialize((HAMSTER_TYPES)photonView.instantiationData[1]);

            // if it's a gravity hamster
            _bubble.isPlasma = (bool)photonView.instantiationData[2];
            _bubble.team = (int)photonView.instantiationData[3];
            _bubble.locked = true;

            // Find the proper bubble manager but DON'T add yet
            _bubble.HomeBubbleManager = FindHomeBubbleManager((int)photonView.instantiationData[3]);

            // Hold onto our node
            _bubble.node = (int)photonView.instantiationData[4];

            // Add ourselves to the networked bubble manager
            _bubble.HomeBubbleManager.GetComponent<NetworkedBubbleManager>().HoldLineBubble(_bubble);

            // Hide
            _bubble.gameObject.SetActive(false);

            // If this was a bubble generated by the bubble manager
        } else if (spawnType == -1) {
            // initialize the bubble
            _bubble.Initialize((HAMSTER_TYPES)photonView.instantiationData[1]);

            // if it's a gravity hamster
            _bubble.isPlasma = (bool)photonView.instantiationData[2];
            _bubble.team = (int)photonView.instantiationData[3];
            _bubble.locked = true;

            // Find the proper bubble manager
            _bubble.HomeBubbleManager = FindHomeBubbleManager((int)photonView.instantiationData[3]);
            _bubble.HomeBubbleManager.AddBubble(_bubble, (int)photonView.instantiationData[4]);

            if (PhotonNetwork.isMasterClient) {
                _bubble.HomeBubbleManager.boardChangedEvent.AddListener(SendSynchCheck);
            }
        // If this was a bubble caught by the player
        } else if (spawnType >= 0) {
            PlayerController playerController = playerSpawner.GetPlayer((int)photonView.instantiationData[0]);
            playerController.heldBall = _bubble;
            playerController.heldBall.team = playerController.team;
            playerController.heldBall.PlayerController = playerController;
            playerController.heldBall.Initialize((HAMSTER_TYPES)photonView.instantiationData[1]);
            playerController.heldBall.GetComponent<CircleCollider2D>().enabled = false;
            playerController.heldBall.HideSprites();

            // if it's a gravity hamster
            playerController.heldBall.isPlasma = (bool)photonView.instantiationData[2];

        // Otherwise it's parent should be a water bubble
        } else if (spawnType == -50) {
            // Find the parent water bubble
            PhotonView parentBubble = PhotonView.Find((int)photonView.instantiationData[4]);
            parentBubble.GetComponent<WaterBubble>().CaughtBubble = _bubble;
            transform.parent = parentBubble.transform;

            transform.localPosition = new Vector3(0f, 0f, 0f);
            _bubble.team = (int)photonView.instantiationData[3];
            _bubble.PlayerController = null;
            _bubble.Initialize((HAMSTER_TYPES)photonView.instantiationData[1]);
            _bubble.GetComponent<CircleCollider2D>().enabled = false;

            _bubble.isPlasma = (bool)photonView.instantiationData[2];
        }
    }

    public void OnPhotonSerializeView(PhotonStream stream, PhotonMessageInfo info) {
        if (stream.isWriting) {

        } else {

        }
    }

    // Update is called once per frame
    void Update () {
		if(PhotonNetwork.isMasterClient && _bubble.HomeBubbleManager != null && _bubble.HomeBubbleManager.BoardIsStable) {
            _syncTimer += Time.deltaTime;
            if(_syncTimer >= _syncTime) {
                SendSynchCheck();
                _syncTimer = 0f;
            }
        } else {
            _syncTimer = 0f;
        }
	}
    
    [PunRPC]
    void AddToBoard(int team, int node) {
        // Find the proper bubble manager
        _bubble.HomeBubbleManager = FindHomeBubbleManager(team);

        // If the node doesn't line up with our current node
        if (_bubble.node != node) {
            // something went wrong and we need to correct
            _bubble.HomeBubbleManager.AddBubble(_bubble, node);
        }
        //_bubble.CollisionWithBoard(_bubble.HomeBubbleManager);

        if(PhotonNetwork.isMasterClient) {
            _bubble.HomeBubbleManager.boardChangedEvent.AddListener(SendSynchCheck);
        }
    }

    BubbleManager FindHomeBubbleManager(int team) {
        BubbleManager homeBubMan = null;

        _bubble.team = team;
        BubbleManager[] bubManagers = FindObjectsOfType<BubbleManager>();
        foreach (BubbleManager bMan in bubManagers) {
            if (bMan.team == team) {
                homeBubMan = bMan;
                break;
            }
        }

        return homeBubMan;
    }

    // Only used by master client
    public void SendSynchCheck() {
        photonView.RPC("SynchCheck", PhotonTargets.Others, _bubble.node, _bubble.locked);
    }

    [PunRPC]
    void SynchCheck(int node, bool locked) {
        if (_bubble.HomeBubbleManager.BoardIsStable) {
            //if (_bubble.node != node) {
            //    Debug.LogError("Bubble at node " + _bubble.node + " out of synch, moveing to node " + node);

            //    _bubble.node = node;
            //    _bubble.transform.position = _bubble.HomeBubbleManager.nodeList[node].nPosition;
            //}

            if (_bubble.locked != locked) {
                _bubble.locked = locked;
                if (_bubble.locked) {
                    _bubble.transform.position = _bubble.HomeBubbleManager.nodeList[node].nPosition;
                    _bubble.gameObject.SetActive(true);
                }
            }
        }
    }

    [PunRPC]
    void NetworkDrop(int inc) {
        _bubble.GenerateDropJunk(inc);
    }

    private void OnDestroy() {
        Debug.Log("Network destroy bubble 2");

        if (PhotonNetwork.connectedAndReady) {
            // Only the master client should try and destroy things
            if (PhotonNetwork.isMasterClient) {
                if (PhotonNetwork.player != photonView.owner) {
                    photonView.TransferOwnership(PhotonNetwork.masterClient);
                }
                PhotonNetwork.Destroy(gameObject);
            }
        }
    }
}
